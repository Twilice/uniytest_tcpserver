 --- current ---

 actually test the code unity/javascript/server code...


 * json communication finally established between server + javascript client.
  - needs mayor refactor + cleaning
  - test send chatmessage via html <input>
  - map unity with javascript and pray we won't have as much json parse issues again.

 * look into possibility to include support for webgl (websocket)
https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_server

 * host somewhere to test real life case
  - also include test from android .apk
  - also test if ws (http) work outside of localhost, and then check if we can get https working. Or if that is more of a server IT issue rather than coding issue.

 --- todo ---

 * fix  error server crash because websocket timeout


 * refactoring

 * little better error handling
 
 * more service like for game
  
* fix
---- > '0x00' is an invalid start of a value. Path: $ | LineNumber: 0 | BytePositionInLine: 0.'0x00' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 0.
 when webclient is closed/refreshed

 * javascript timezone.
	- not important, we don't actually care about pure html? It should just send to unity anyways?

 --- todo later ---
 
  * need to fix the bytebuffersize to something else than a static 8192 size....

 * make multiple services - game / chat / etc.
 
 * make an actual game - current plan is shared painting + chat

 * figure out how to continuously listen on messages from the client. But without permanently listening to read request. 
	- We want to be able to have 50k clients, but not listen to 50k clients at the same time.
 
 * dispose tcpClients if they are disconnected... now we only do it in broadcast. (not fixed yet duo some confusion how socket/tcpClient/stream resources should be disposed correctly)

 --- think about ---

 * what should the datapackages contain? How to share same structure? (wcf like with libfile?)

 * how to distribute between each service
  - and how to make sure the server does not send to much small update data packages. 
	(1 thread for read and 1 for write is fine. But if we accidentally have 2 thread for write is not fine)

 * force user syncronization? For reconnection



 
 **

 Maybe I'm wrongthinking it again. Maybe it should be more like I initially thought, but with asyncReads instead. So client doesn't have any listener. 
 Server gives the async some execution time (howto?). And communicates back via the same tcpClient class unless disconnected. Then ignore.
  The question is still when should tcpClient be disposed if the request is already handled, but we want the server to relay messages to client without client asking for it.

  tl:dr
  ignore the planned thread sharing between sockets "don't tick/read more than needed". And just make it work for now. Don't need to handle +50k clients at this moment I guess
